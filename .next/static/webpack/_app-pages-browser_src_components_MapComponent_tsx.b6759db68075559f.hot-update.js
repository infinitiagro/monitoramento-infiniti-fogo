"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_MapComponent_tsx",{

/***/ "(app-pages-browser)/./src/components/MapComponent.tsx":
/*!*****************************************!*\
  !*** ./src/components/MapComponent.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var xmldom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xmldom */ \"(app-pages-browser)/./node_modules/.pnpm/xmldom@0.6.0/node_modules/xmldom/lib/dom-parser.js\");\n/* harmony import */ var _tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tmcw/togeojson */ \"(app-pages-browser)/./node_modules/.pnpm/@tmcw+togeojson@7.1.1/node_modules/@tmcw/togeojson/dist/togeojson.es.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Define URLs for INPE KML data\nconst inpeUrls = [\n    'https://dataserver-coids.inpe.br/queimadas/queimadas/focos/kml/estados-48h/focos_frentes_MT.kml',\n    'https://dataserver-coids.inpe.br/queimadas/queimadas/focos/kml/estados-48h/focos_frentes_MS.kml'\n];\n// Custom icon for fire points\nconst fireIcon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().icon({\n    iconUrl: 'https://img.icons8.com/plasticine/100/fire-element--v1.png',\n    iconSize: [\n        30,\n        30\n    ],\n    iconAnchor: [\n        15,\n        30\n    ],\n    popupAnchor: [\n        0,\n        -30\n    ] // point from which the popup should open relative to the iconAnchor\n});\n// Refresh interval in milliseconds (10 minutes = 600 seconds * 1000 ms/s)\nconst REFRESH_INTERVAL = 600 * 1000;\nconst MapComponent = (param)=>{\n    let { center, zoom } = param;\n    _s();\n    const mapContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [fireDataLayers, setFireDataLayers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const farmLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref to store farm layer\n    const layersControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref for layers control\n    // Function to fetch and process KML data (for fire points) via internal API proxy\n    const fetchAndProcessFireKML = async (inpeUrl)=>{\n        try {\n            // Use the internal API route as a proxy\n            const proxyApiUrl = \"/api/inpe-kml?url=\".concat(encodeURIComponent(inpeUrl));\n            const response = await fetch(proxyApiUrl);\n            if (!response.ok) {\n                throw new Error(\"Erro no proxy interno! status: \".concat(response.status, \" para \").concat(inpeUrl));\n            }\n            const kmlText = await response.text();\n            return processKMLText(kmlText, inpeUrl);\n        } catch (error) {\n            console.error(\"Erro ao buscar ou processar KML de \".concat(inpeUrl, \" via proxy interno:\"), error);\n            return null;\n        }\n    };\n    // Helper function to process KML text into GeoJSON layer\n    const processKMLText = (kmlText, sourceUrl)=>{\n        try {\n            const parser = new xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n            const kmlDoc = parser.parseFromString(kmlText, 'text/xml');\n            // Check for parser errors\n            const parsererrorNS = kmlDoc.getElementsByTagName(\"parsererror\");\n            if (parsererrorNS.length > 0) {\n                console.error(\"Erro de parsing KML de \".concat(sourceUrl, \":\"), parsererrorNS[0].textContent);\n                throw new Error('Erro de parsing KML');\n            }\n            const geojson = (0,_tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__.kml)(kmlDoc); // Assuming fire data are points\n            // Filter out non-point features if necessary\n            const pointFeatures = geojson.features.filter((feature)=>{\n                var _feature_geometry;\n                return ((_feature_geometry = feature.geometry) === null || _feature_geometry === void 0 ? void 0 : _feature_geometry.type) === 'Point';\n            });\n            const pointFeatureCollection = {\n                type: 'FeatureCollection',\n                features: pointFeatures\n            };\n            if (pointFeatures.length === 0) {\n                console.log(\"Nenhum foco de inc\\xeandio (ponto) encontrado em \".concat(sourceUrl));\n                // Return an empty layer group instead of null to avoid issues in Promise.all\n                return leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON();\n            }\n            const layer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(pointFeatureCollection, {\n                pointToLayer: (feature, latlng)=>{\n                    return leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker(latlng, {\n                        icon: fireIcon\n                    });\n                },\n                onEachFeature: (feature, layer)=>{\n                    if (feature.properties) {\n                        let popupContent = \"<b>\".concat(feature.properties.name || 'Foco de Incêndio', \"</b>\");\n                        if (feature.properties.description) {\n                            const desc = feature.properties.description;\n                            // Extract specific fields from the description table\n                            const dateTimeMatch = desc.match(/<td>Data Hora UTC<\\/td><td>([^<]+)<\\/td>/);\n                            const satelliteMatch = desc.match(/<td>Satélite<\\/td><td>([^<]+)<\\/td>/);\n                            const municipioMatch = desc.match(/<td>Município<\\/td><td>([^<]+)<\\/td>/);\n                            const estadoMatch = desc.match(/<td>Estado<\\/td><td>([^<]+)<\\/td>/);\n                            if (dateTimeMatch === null || dateTimeMatch === void 0 ? void 0 : dateTimeMatch[1]) popupContent += \"<br/>Data/Hora: \".concat(dateTimeMatch[1]);\n                            if (satelliteMatch === null || satelliteMatch === void 0 ? void 0 : satelliteMatch[1]) popupContent += \"<br/>Sat\\xe9lite: \".concat(satelliteMatch[1]);\n                            if (municipioMatch === null || municipioMatch === void 0 ? void 0 : municipioMatch[1]) popupContent += \"<br/>Munic\\xedpio: \".concat(municipioMatch[1]);\n                            if (estadoMatch === null || estadoMatch === void 0 ? void 0 : estadoMatch[1]) popupContent += \"<br/>Estado: \".concat(estadoMatch[1]);\n                        }\n                        layer.bindPopup(popupContent);\n                    }\n                }\n            });\n            return layer;\n        } catch (parseError) {\n            console.error(\"Erro ao processar KML de \".concat(sourceUrl, \":\"), parseError);\n            return null; // Return null on error\n        }\n    };\n    // Function to update fire data\n    const updateFireData = async ()=>{\n        var _mapRef_current;\n        if (!mapRef.current) return;\n        console.log('Atualizando dados de incêndio via proxy interno...');\n        const newLayers = await Promise.all(inpeUrls.map((url)=>fetchAndProcessFireKML(url)));\n        const validNewLayers = newLayers.filter((layer)=>layer !== null);\n        // Remove old layers from map and control\n        fireDataLayers.forEach((layer)=>{\n            var _mapRef_current;\n            (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.removeLayer(layer);\n            if (layersControlRef.current) {\n                layersControlRef.current.removeLayer(layer);\n            }\n        });\n        // Add new layers to map and control\n        const fireLayerGroup = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup(validNewLayers);\n        (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.addLayer(fireLayerGroup);\n        if (layersControlRef.current) {\n            layersControlRef.current.addOverlay(fireLayerGroup, \"Focos de Incêndio (INPE)\");\n        }\n        // Update state\n        setFireDataLayers(validNewLayers); // Store individual layers for removal later\n        console.log(\"Dados de inc\\xeandio atualizados. \".concat(validNewLayers.reduce((acc, layer)=>acc + layer.getLayers().length, 0), \" focos carregados.\"));\n    };\n    // Function to load and process farm KML data\n    const loadFarmKML = async (kmlUrl, layerName)=>{\n        try {\n            console.log(\"Carregando dados KML da fazenda de \".concat(kmlUrl, \"...\"));\n            const response = await fetch(kmlUrl);\n            if (!response.ok) {\n                throw new Error(\"Erro ao carregar KML da fazenda! Status: \".concat(response.status));\n            }\n            const kmlText = await response.text();\n            console.log(\"KML da fazenda carregado com sucesso, processando...\");\n            const parser = new xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n            const kmlDoc = parser.parseFromString(kmlText, \"text/xml\");\n            // Check for parser errors\n            const parsererrorNS = kmlDoc.getElementsByTagName(\"parsererror\");\n            if (parsererrorNS.length > 0) {\n                console.error(\"Erro de parsing KML da fazenda:\", parsererrorNS[0].textContent);\n                throw new Error(\"Erro de parsing KML da fazenda\");\n            }\n            const geojson = (0,_tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__.kml)(kmlDoc);\n            console.log(\"GeoJSON processado:\", geojson);\n            if (!geojson || !geojson.features || geojson.features.length === 0) {\n                console.warn(\"Nenhuma feature encontrada no KML da fazenda\");\n                return;\n            }\n            const newFarmLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(geojson, {\n                style: function(feature) {\n                    var _feature_properties;\n                    let style = {\n                        color: \"#ff0000\",\n                        weight: 3,\n                        opacity: 0.8,\n                        fillOpacity: 0.2,\n                        fillColor: \"#ff0000\"\n                    };\n                    // Aplicar estilos baseados no styleUrl se disponível\n                    if (feature === null || feature === void 0 ? void 0 : (_feature_properties = feature.properties) === null || _feature_properties === void 0 ? void 0 : _feature_properties.styleUrl) {\n                        if (feature.properties.styleUrl.includes(\"PolyStyle007\")) {\n                            style.color = \"#00ffff\";\n                            style.fillColor = \"#00ffff\";\n                            style.fillOpacity = 0.1;\n                            style.weight = 2;\n                        } else if (feature.properties.styleUrl.includes(\"PolyStyle0012\")) {\n                            style.color = \"#fcb4d4\";\n                            style.fillColor = \"#fcb4d4\";\n                            style.fillOpacity = 0.1;\n                            style.weight = 2;\n                        } else if (feature.properties.styleUrl.includes(\"PolyStyle00159\")) {\n                            // Estilo do KML fornecido\n                            style.color = \"#f0f0f0\";\n                            style.fillColor = \"#f0f0f0\";\n                            style.fillOpacity = 0.07;\n                            style.weight = 3;\n                        }\n                    }\n                    return style;\n                },\n                onEachFeature: function(feature, layer) {\n                    let popupContent = feature.properties && feature.properties.name ? \"<b>\".concat(feature.properties.name, \"</b>\") : \"<b>Perímetro da Fazenda</b>\";\n                    layer.bindPopup(popupContent);\n                }\n            });\n            if (mapRef.current) {\n                newFarmLayer.addTo(mapRef.current);\n                console.log(\"Camada da fazenda \".concat(layerName, \" adicionada ao mapa\"));\n                // Add farm layer to the control\n                if (layersControlRef.current) {\n                    layersControlRef.current.addOverlay(newFarmLayer, layerName);\n                    console.log(\"Camada da fazenda \".concat(layerName, \" adicionada ao controle de camadas\"));\n                }\n                // Fit map to farm bounds (only for the first KML loaded, or if no other farm KML is loaded)\n                if (!farmLayerRef.current) {\n                    const bounds = newFarmLayer.getBounds();\n                    if (bounds.isValid()) {\n                        mapRef.current.fitBounds(bounds, {\n                            padding: [\n                                20,\n                                20\n                            ]\n                        });\n                        console.log(\"Mapa ajustado aos limites da fazenda\");\n                    }\n                }\n                farmLayerRef.current = newFarmLayer; // Store the last loaded farm layer\n            }\n        } catch (error) {\n            console.error(\"Erro ao carregar KML da fazenda \".concat(kmlUrl, \":\"), error);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MapComponent.useEffect\": ()=>{\n            let isMounted = true;\n            let intervalId = null;\n            if (mapContainerRef.current && !mapRef.current) {\n                // Initialize map\n                mapRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map(mapContainerRef.current, {\n                    center: center,\n                    zoom: zoom\n                });\n                // --- Define Base Layers ---\n                const osmLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n                });\n                const esriSatelliteLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {\n                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'\n                });\n                // Add default base layer (OSM)\n                osmLayer.addTo(mapRef.current);\n                // --- Define Overlay Layers ---\n                const overlayMaps = {}; // Will be populated later\n                // --- Add Layers Control ---\n                const baseMaps = {\n                    \"OpenStreetMap\": osmLayer,\n                    \"Satélite (ESRI)\": esriSatelliteLayer\n                };\n                layersControlRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().control.layers(baseMaps, overlayMaps).addTo(mapRef.current);\n                // Fix for marker icons\n                delete (leaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon).Default.prototype._getIconUrl;\n                leaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon.Default.mergeOptions({\n                    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',\n                    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',\n                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'\n                });\n                // Load Farm KML data\n                const farmKMLs = [\n                    {\n                        url: '/doc.kml',\n                        name: 'Fazenda Atalaia'\n                    }\n                ];\n                farmKMLs.forEach({\n                    \"MapComponent.useEffect\": (farm)=>{\n                        loadFarmKML(farm.url, farm.name);\n                    }\n                }[\"MapComponent.useEffect\"]);\n                // Initial fetch of INPE Fire KML data\n                updateFireData(); // This will now also add fire layers to the control\n                // Set up interval for periodic updates\n                intervalId = setInterval(updateFireData, REFRESH_INTERVAL);\n            }\n            // Cleanup function\n            return ({\n                \"MapComponent.useEffect\": ()=>{\n                    isMounted = false;\n                    if (intervalId) {\n                        clearInterval(intervalId);\n                    }\n                // Optional: Clean up map instance if component unmounts\n                // if (mapRef.current) {\n                //   mapRef.current.remove();\n                //   mapRef.current = null;\n                // }\n                }\n            })[\"MapComponent.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"MapComponent.useEffect\"], [\n        center,\n        zoom\n    ]); // Only re-run if center/zoom props change\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapContainerRef,\n        style: {\n            height: '100vh',\n            width: '100%'\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\Aplicativo_monitoramento de incendios\\\\fire_monitor_app_backup\\\\webapp\\\\src\\\\components\\\\MapComponent.tsx\",\n        lineNumber: 314,\n        columnNumber: 10\n    }, undefined);\n};\n_s(MapComponent, \"K+oeeKqUn14Zt1fH14kWfUl7bbM=\");\n_c = MapComponent;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapComponent);\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL01hcENvbXBvbmVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDbkM7QUFDVTtBQUNDO0FBQ0c7QUFRdEMsZ0NBQWdDO0FBQ2hDLE1BQU1PLFdBQVc7SUFDZjtJQUNBO0NBR0Q7QUFFRCw4QkFBOEI7QUFDOUIsTUFBTUMsV0FBV0osbURBQU0sQ0FBQztJQUNwQk0sU0FBUztJQUNUQyxVQUFVO1FBQUM7UUFBSTtLQUFHO0lBQ2xCQyxZQUFZO1FBQUM7UUFBSTtLQUFHO0lBQ3BCQyxhQUFhO1FBQUM7UUFBRyxDQUFDO0tBQUcsQ0FBQyxvRUFBb0U7QUFDOUY7QUFFQSwwRUFBMEU7QUFDMUUsTUFBTUMsbUJBQW1CLE1BQU07QUFFL0IsTUFBTUMsZUFBNEM7UUFBQyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRTs7SUFDakUsTUFBTUMsa0JBQWtCaEIsNkNBQU1BLENBQWlCO0lBQy9DLE1BQU1pQixTQUFTakIsNkNBQU1BLENBQWU7SUFDcEMsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR2xCLCtDQUFRQSxDQUFjLEVBQUU7SUFDcEUsTUFBTW1CLGVBQWVwQiw2Q0FBTUEsQ0FBbUIsT0FBTywwQkFBMEI7SUFDL0UsTUFBTXFCLG1CQUFtQnJCLDZDQUFNQSxDQUEwQixPQUFPLHlCQUF5QjtJQUV6RixrRkFBa0Y7SUFDbEYsTUFBTXNCLHlCQUF5QixPQUFPQztRQUNwQyxJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU1DLGNBQWMscUJBQWlELE9BQTVCQyxtQkFBbUJGO1lBQzVELE1BQU1HLFdBQVcsTUFBTUMsTUFBTUg7WUFFN0IsSUFBSSxDQUFDRSxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSxrQ0FBMEROLE9BQXhCRyxTQUFTSSxNQUFNLEVBQUMsVUFBZ0IsT0FBUlA7WUFDNUU7WUFDQSxNQUFNUSxVQUFVLE1BQU1MLFNBQVNNLElBQUk7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QUFPO2dCQUV2Rix1QkFBdUI7Z0JBQ3ZCLE9BQU8scURBQU8sQ0FBQzhDLE9BQU8sQ0FBQ0MsU0FBUyxDQUFTQyxXQUFXO2dCQUNwRHRILG1EQUFNLENBQUNvSCxPQUFPLENBQUNHLFlBQVksQ0FBQztvQkFDMUJDLGVBQWU7b0JBQ2ZsSCxTQUFTO29CQUNUbUgsV0FBVztnQkFDYjtnQkFFQSxxQkFBcUI7Z0JBQ3JCLE1BQU1DLFdBQVc7b0JBQ2Y7d0JBQUUvQyxLQUNBO3dCQUFZaEIsTUFBTTtvQkFDcEI7aUJBR0Q7Z0JBRUQrRCxTQUFTN0MsT0FBTzs4Q0FBQzhDLENBQUFBO3dCQUNmckMsWUFBWXFDLEtBQUtoRCxHQUFHLEVBQUVnRCxLQUFLaEUsSUFBSTtvQkFDakM7O2dCQUVBLHNDQUFzQztnQkFDdENVLGtCQUFrQixvREFBb0Q7Z0JBRXRFLHVDQUF1QztnQkFDdkNxQyxhQUFha0IsWUFBWXZELGdCQUFnQjNEO1lBQzNDO1lBRUEsbUJBQW1CO1lBQ25COzBDQUFPO29CQUNMK0YsWUFBWTtvQkFDWixJQUFJQyxZQUFZO3dCQUNkbUIsY0FBY25CO29CQUNoQjtnQkFDQSx3REFBd0Q7Z0JBQ3hELHdCQUF3QjtnQkFDeEIsNkJBQTZCO2dCQUM3QiwyQkFBMkI7Z0JBQzNCLElBQUk7Z0JBQ047O1FBQ0YsdURBQXVEO1FBQ3ZEO2lDQUFHO1FBQUM5RjtRQUFRQztLQUFLLEdBQUcsMENBQTBDO0lBRzlELHFCQUFPLDhEQUFDaUg7UUFBSUMsS0FBS2pIO1FBQWlCNkUsT0FBTztZQUFFcUMsUUFBUTtZQUFTQyxPQUFPO1FBQU87Ozs7OztBQUM1RTtHQTNSTXRIO0tBQUFBO0FBNlJOLGlFQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJEOlxcQXBsaWNhdGl2b19tb25pdG9yYW1lbnRvIGRlIGluY2VuZGlvc1xcZmlyZV9tb25pdG9yX2FwcF9iYWNrdXBcXHdlYmFwcFxcc3JjXFxjb21wb25lbnRzXFxNYXBDb21wb25lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcbmltcG9ydCAnbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzJztcbmltcG9ydCB7IERPTVBhcnNlciB9IGZyb20gJ3htbGRvbSc7XG5pbXBvcnQgeyBrbWwgfSBmcm9tICdAdG1jdy90b2dlb2pzb24nO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlQ29sbGVjdGlvbiwgUG9pbnQgfSBmcm9tICdnZW9qc29uJztcblxuaW50ZXJmYWNlIE1hcENvbXBvbmVudFByb3BzIHtcbiAgY2VudGVyOiBbbnVtYmVyLCBudW1iZXJdO1xuICB6b29tOiBudW1iZXI7XG59XG5cbi8vIERlZmluZSBVUkxzIGZvciBJTlBFIEtNTCBkYXRhXG5jb25zdCBpbnBlVXJscyA9IFtcbiAgJ2h0dHBzOi8vZGF0YXNlcnZlci1jb2lkcy5pbnBlLmJyL3F1ZWltYWRhcy9xdWVpbWFkYXMvZm9jb3Mva21sL2VzdGFkb3MtNDhoL2ZvY29zX2ZyZW50ZXNfTVQua21sJyxcbiAgJ2h0dHBzOi8vZGF0YXNlcnZlci1jb2lkcy5pbnBlLmJyL3F1ZWltYWRhcy9xdWVpbWFkYXMvZm9jb3Mva21sL2VzdGFkb3MtNDhoL2ZvY29zX2ZyZW50ZXNfTVMua21sJ1xuICAvLydodHRwczovL2RhdGFzZXJ2ZXItY29pZHMuaW5wZS5ici9xdWVpbWFkYXMvcXVlaW1hZGFzL2ZvY29zL2ttbC9lc3RhZG9zLTQ4aC9mb2Nvc19mcmVudGVzX0JBLmttbCcsXG4gIC8vJ2h0dHBzOi8vZGF0YXNlcnZlci1jb2lkcy5pbnBlLmJyL3F1ZWltYWRhcy9xdWVpbWFkYXMvZm9jb3Mva21sL2VzdGFkb3MtNDhoL2ZvY29zX2ZyZW50ZXNfTUEua21sJ1xuXTtcblxuLy8gQ3VzdG9tIGljb24gZm9yIGZpcmUgcG9pbnRzXG5jb25zdCBmaXJlSWNvbiA9IEwuaWNvbih7XG4gICAgaWNvblVybDogJ2h0dHBzOi8vaW1nLmljb25zOC5jb20vcGxhc3RpY2luZS8xMDAvZmlyZS1lbGVtZW50LS12MS5wbmcnLCAvLyBVc2luZyBhIHBsYWNlaG9sZGVyIGljb25cbiAgICBpY29uU2l6ZTogWzMwLCAzMF0sIC8vIHNpemUgb2YgdGhlIGljb25cbiAgICBpY29uQW5jaG9yOiBbMTUsIDMwXSwgLy8gcG9pbnQgb2YgdGhlIGljb24gd2hpY2ggd2lsbCBjb3JyZXNwb25kIHRvIG1hcmtlcidzIGxvY2F0aW9uXG4gICAgcG9wdXBBbmNob3I6IFswLCAtMzBdIC8vIHBvaW50IGZyb20gd2hpY2ggdGhlIHBvcHVwIHNob3VsZCBvcGVuIHJlbGF0aXZlIHRvIHRoZSBpY29uQW5jaG9yXG59KTtcblxuLy8gUmVmcmVzaCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgKDEwIG1pbnV0ZXMgPSA2MDAgc2Vjb25kcyAqIDEwMDAgbXMvcylcbmNvbnN0IFJFRlJFU0hfSU5URVJWQUwgPSA2MDAgKiAxMDAwO1xuXG5jb25zdCBNYXBDb21wb25lbnQ6IFJlYWN0LkZDPE1hcENvbXBvbmVudFByb3BzPiA9ICh7IGNlbnRlciwgem9vbSB9KSA9PiB7XG4gIGNvbnN0IG1hcENvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxMLk1hcCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZmlyZURhdGFMYXllcnMsIHNldEZpcmVEYXRhTGF5ZXJzXSA9IHVzZVN0YXRlPEwuR2VvSlNPTltdPihbXSk7XG4gIGNvbnN0IGZhcm1MYXllclJlZiA9IHVzZVJlZjxMLkdlb0pTT04gfCBudWxsPihudWxsKTsgLy8gUmVmIHRvIHN0b3JlIGZhcm0gbGF5ZXJcbiAgY29uc3QgbGF5ZXJzQ29udHJvbFJlZiA9IHVzZVJlZjxMLkNvbnRyb2wuTGF5ZXJzIHwgbnVsbD4obnVsbCk7IC8vIFJlZiBmb3IgbGF5ZXJzIGNvbnRyb2xcblxuICAvLyBGdW5jdGlvbiB0byBmZXRjaCBhbmQgcHJvY2VzcyBLTUwgZGF0YSAoZm9yIGZpcmUgcG9pbnRzKSB2aWEgaW50ZXJuYWwgQVBJIHByb3h5XG4gIGNvbnN0IGZldGNoQW5kUHJvY2Vzc0ZpcmVLTUwgPSBhc3luYyAoaW5wZVVybDogc3RyaW5nKTogUHJvbWlzZTxMLkdlb0pTT04gfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSB0aGUgaW50ZXJuYWwgQVBJIHJvdXRlIGFzIGEgcHJveHlcbiAgICAgIGNvbnN0IHByb3h5QXBpVXJsID0gYC9hcGkvaW5wZS1rbWw/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucGVVcmwpfWA7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHByb3h5QXBpVXJsKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gbm8gcHJveHkgaW50ZXJubyEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30gcGFyYSAke2lucGVVcmx9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBrbWxUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgcmV0dXJuIHByb2Nlc3NLTUxUZXh0KGttbFRleHQsIGlucGVVcmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvIGFvIGJ1c2NhciBvdSBwcm9jZXNzYXIgS01MIGRlICR7aW5wZVVybH0gdmlhIHByb3h5IGludGVybm86YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBwcm9jZXNzIEtNTCB0ZXh0IGludG8gR2VvSlNPTiBsYXllclxuICBjb25zdCBwcm9jZXNzS01MVGV4dCA9IChrbWxUZXh0OiBzdHJpbmcsIHNvdXJjZVVybDogc3RyaW5nKTogTC5HZW9KU09OIHwgbnVsbCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICBjb25zdCBrbWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGttbFRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgICAgIC8vIENoZWNrIGZvciBwYXJzZXIgZXJyb3JzXG4gICAgICAgICAgY29uc3QgcGFyc2VyZXJyb3JOUyA9IGttbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpO1xuICAgICAgICAgIGlmIChwYXJzZXJlcnJvck5TLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJybyBkZSBwYXJzaW5nIEtNTCBkZSAke3NvdXJjZVVybH06YCwgcGFyc2VyZXJyb3JOU1swXS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJybyBkZSBwYXJzaW5nIEtNTCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGdlb2pzb24gPSBrbWwoa21sRG9jKSBhcyBGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD47IC8vIEFzc3VtaW5nIGZpcmUgZGF0YSBhcmUgcG9pbnRzXG5cbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG5vbi1wb2ludCBmZWF0dXJlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBjb25zdCBwb2ludEZlYXR1cmVzID0gZ2VvanNvbi5mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiBmZWF0dXJlLmdlb21ldHJ5Py50eXBlID09PSAnUG9pbnQnKTtcbiAgICAgICAgICBjb25zdCBwb2ludEZlYXR1cmVDb2xsZWN0aW9uOiBGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD4gPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgIGZlYXR1cmVzOiBwb2ludEZlYXR1cmVzIGFzIGFueVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocG9pbnRGZWF0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYE5lbmh1bSBmb2NvIGRlIGluY8OqbmRpbyAocG9udG8pIGVuY29udHJhZG8gZW0gJHtzb3VyY2VVcmx9YCk7XG4gICAgICAgICAgICAgIC8vIFJldHVybiBhbiBlbXB0eSBsYXllciBncm91cCBpbnN0ZWFkIG9mIG51bGwgdG8gYXZvaWQgaXNzdWVzIGluIFByb21pc2UuYWxsXG4gICAgICAgICAgICAgIHJldHVybiBMLmdlb0pTT04oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsYXllciA9IEwuZ2VvSlNPTihwb2ludEZlYXR1cmVDb2xsZWN0aW9uIGFzIGFueSwge1xuICAgICAgICAgICAgcG9pbnRUb0xheWVyOiAoZmVhdHVyZSwgbGF0bG5nKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBMLm1hcmtlcihsYXRsbmcsIHsgaWNvbjogZmlyZUljb24gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FYWNoRmVhdHVyZTogKGZlYXR1cmUsIGxheWVyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9wdXBDb250ZW50ID0gYDxiPiR7ZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWUgfHwgJ0ZvY28gZGUgSW5jw6puZGlvJ308L2I+YDtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBmZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc3BlY2lmaWMgZmllbGRzIGZyb20gdGhlIGRlc2NyaXB0aW9uIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVUaW1lTWF0Y2ggPSBkZXNjLm1hdGNoKC88dGQ+RGF0YSBIb3JhIFVUQzxcXC90ZD48dGQ+KFtePF0rKTxcXC90ZD4vKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2F0ZWxsaXRlTWF0Y2ggPSBkZXNjLm1hdGNoKC88dGQ+U2F0w6lsaXRlPFxcL3RkPjx0ZD4oW148XSspPFxcL3RkPi8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtdW5pY2lwaW9NYXRjaCA9IGRlc2MubWF0Y2goLzx0ZD5NdW5pY8OtcGlvPFxcL3RkPjx0ZD4oW148XSspPFxcL3RkPi8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RhZG9NYXRjaCA9IGRlc2MubWF0Y2goLzx0ZD5Fc3RhZG88XFwvdGQ+PHRkPihbXjxdKyk8XFwvdGQ+Lyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVUaW1lTWF0Y2g/LlsxXSkgcG9wdXBDb250ZW50ICs9IGA8YnIvPkRhdGEvSG9yYTogJHtkYXRlVGltZU1hdGNoWzFdfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXRlbGxpdGVNYXRjaD8uWzFdKSBwb3B1cENvbnRlbnQgKz0gYDxici8+U2F0w6lsaXRlOiAke3NhdGVsbGl0ZU1hdGNoWzFdfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdW5pY2lwaW9NYXRjaD8uWzFdKSBwb3B1cENvbnRlbnQgKz0gYDxici8+TXVuaWPDrXBpbzogJHttdW5pY2lwaW9NYXRjaFsxXX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXN0YWRvTWF0Y2g/LlsxXSkgcG9wdXBDb250ZW50ICs9IGA8YnIvPkVzdGFkbzogJHtlc3RhZG9NYXRjaFsxXX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXllci5iaW5kUG9wdXAocG9wdXBDb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvIGFvIHByb2Nlc3NhciBLTUwgZGUgJHtzb3VyY2VVcmx9OmAsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgIHJldHVybiBudWxsOyAvLyBSZXR1cm4gbnVsbCBvbiBlcnJvclxuICAgICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGZpcmUgZGF0YVxuICBjb25zdCB1cGRhdGVGaXJlRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1hcFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc29sZS5sb2coJ0F0dWFsaXphbmRvIGRhZG9zIGRlIGluY8OqbmRpbyB2aWEgcHJveHkgaW50ZXJuby4uLicpO1xuICAgIGNvbnN0IG5ld0xheWVycyA9IGF3YWl0IFByb21pc2UuYWxsKGlucGVVcmxzLm1hcCh1cmwgPT4gZmV0Y2hBbmRQcm9jZXNzRmlyZUtNTCh1cmwpKSk7XG4gICAgY29uc3QgdmFsaWROZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKGxheWVyID0+IGxheWVyICE9PSBudWxsKSBhcyBMLkdlb0pTT05bXTtcblxuICAgIC8vIFJlbW92ZSBvbGQgbGF5ZXJzIGZyb20gbWFwIGFuZCBjb250cm9sXG4gICAgZmlyZURhdGFMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgIG1hcFJlZi5jdXJyZW50Py5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgIGlmIChsYXllcnNDb250cm9sUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxheWVyc0NvbnRyb2xSZWYuY3VycmVudC5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFkZCBuZXcgbGF5ZXJzIHRvIG1hcCBhbmQgY29udHJvbFxuICAgIGNvbnN0IGZpcmVMYXllckdyb3VwID0gTC5sYXllckdyb3VwKHZhbGlkTmV3TGF5ZXJzKTtcbiAgICBtYXBSZWYuY3VycmVudD8uYWRkTGF5ZXIoZmlyZUxheWVyR3JvdXApO1xuICAgIGlmIChsYXllcnNDb250cm9sUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGF5ZXJzQ29udHJvbFJlZi5jdXJyZW50LmFkZE92ZXJsYXkoZmlyZUxheWVyR3JvdXAsIFwiRm9jb3MgZGUgSW5jw6puZGlvIChJTlBFKVwiKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICBzZXRGaXJlRGF0YUxheWVycyh2YWxpZE5ld0xheWVycyk7IC8vIFN0b3JlIGluZGl2aWR1YWwgbGF5ZXJzIGZvciByZW1vdmFsIGxhdGVyXG4gICAgY29uc29sZS5sb2coYERhZG9zIGRlIGluY8OqbmRpbyBhdHVhbGl6YWRvcy4gJHt2YWxpZE5ld0xheWVycy5yZWR1Y2UoKGFjYywgbGF5ZXIpID0+IGFjYyArIGxheWVyLmdldExheWVycygpLmxlbmd0aCwgMCl9IGZvY29zIGNhcnJlZ2Fkb3MuYCk7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gbG9hZCBhbmQgcHJvY2VzcyBmYXJtIEtNTCBkYXRhXG4gIGNvbnN0IGxvYWRGYXJtS01MID0gYXN5bmMgKGttbFVybDogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgQ2FycmVnYW5kbyBkYWRvcyBLTUwgZGEgZmF6ZW5kYSBkZSAke2ttbFVybH0uLi5gKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goa21sVXJsKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gYW8gY2FycmVnYXIgS01MIGRhIGZhemVuZGEhIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGttbFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIktNTCBkYSBmYXplbmRhIGNhcnJlZ2FkbyBjb20gc3VjZXNzbywgcHJvY2Vzc2FuZG8uLi5cIik7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGttbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoa21sVGV4dCwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHBhcnNlciBlcnJvcnNcbiAgICAgIGNvbnN0IHBhcnNlcmVycm9yTlMgPSBrbWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKTtcbiAgICAgIGlmIChwYXJzZXJlcnJvck5TLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gZGUgcGFyc2luZyBLTUwgZGEgZmF6ZW5kYTpcIiwgcGFyc2VyZXJyb3JOU1swXS50ZXh0Q29udGVudCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm8gZGUgcGFyc2luZyBLTUwgZGEgZmF6ZW5kYVwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZ2VvanNvbiA9IGttbChrbWxEb2MpO1xuICAgICAgY29uc29sZS5sb2coXCJHZW9KU09OIHByb2Nlc3NhZG86XCIsIGdlb2pzb24pO1xuXG4gICAgICBpZiAoIWdlb2pzb24gfHwgIWdlb2pzb24uZmVhdHVyZXMgfHwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTmVuaHVtYSBmZWF0dXJlIGVuY29udHJhZGEgbm8gS01MIGRhIGZhemVuZGFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3RmFybUxheWVyID0gTC5nZW9KU09OKGdlb2pzb24gYXMgYW55LCB7XG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgIGxldCBzdHlsZTogTC5QYXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZjAwMDBcIiwgLy8gQ29yIHZlcm1lbGhhIHBhZHLDo28gcGFyYSBtZWxob3IgdmlzaWJpbGlkYWRlXG4gICAgICAgICAgICB3ZWlnaHQ6IDMsIFxuICAgICAgICAgICAgb3BhY2l0eTogMC44LCBcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwiI2ZmMDAwMFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcGxpY2FyIGVzdGlsb3MgYmFzZWFkb3Mgbm8gc3R5bGVVcmwgc2UgZGlzcG9uw612ZWxcbiAgICAgICAgICBpZiAoZmVhdHVyZT8ucHJvcGVydGllcz8uc3R5bGVVcmwpIHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGVVcmwuaW5jbHVkZXMoXCJQb2x5U3R5bGUwMDdcIikpIHsgXG4gICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gXCIjMDBmZmZmXCI7IFxuICAgICAgICAgICAgICBzdHlsZS5maWxsQ29sb3IgPSBcIiMwMGZmZmZcIjtcbiAgICAgICAgICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSAwLjE7IFxuICAgICAgICAgICAgICBzdHlsZS53ZWlnaHQgPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGVVcmwuaW5jbHVkZXMoXCJQb2x5U3R5bGUwMDEyXCIpKSB7IFxuICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IFwiI2ZjYjRkNFwiOyBcbiAgICAgICAgICAgICAgc3R5bGUuZmlsbENvbG9yID0gXCIjZmNiNGQ0XCI7XG4gICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gMC4xOyBcbiAgICAgICAgICAgICAgc3R5bGUud2VpZ2h0ID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlVXJsLmluY2x1ZGVzKFwiUG9seVN0eWxlMDAxNTlcIikpIHtcbiAgICAgICAgICAgICAgLy8gRXN0aWxvIGRvIEtNTCBmb3JuZWNpZG9cbiAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSBcIiNmMGYwZjBcIjtcbiAgICAgICAgICAgICAgc3R5bGUuZmlsbENvbG9yID0gXCIjZjBmMGYwXCI7XG4gICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gMC4wNztcbiAgICAgICAgICAgICAgc3R5bGUud2VpZ2h0ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LFxuICAgICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgICAgICBsZXQgcG9wdXBDb250ZW50ID0gZmVhdHVyZS5wcm9wZXJ0aWVzICYmIGZlYXR1cmUucHJvcGVydGllcy5uYW1lID8gYDxiPiR7ZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWV9PC9iPmAgOiBcIjxiPlBlcsOtbWV0cm8gZGEgRmF6ZW5kYTwvYj5cIjtcbiAgICAgICAgICBsYXllci5iaW5kUG9wdXAocG9wdXBDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXBSZWYuY3VycmVudCkge1xuICAgICAgICBuZXdGYXJtTGF5ZXIuYWRkVG8obWFwUmVmLmN1cnJlbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2FtYWRhIGRhIGZhemVuZGEgJHtsYXllck5hbWV9IGFkaWNpb25hZGEgYW8gbWFwYWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGZhcm0gbGF5ZXIgdG8gdGhlIGNvbnRyb2xcbiAgICAgICAgaWYgKGxheWVyc0NvbnRyb2xSZWYuY3VycmVudCkge1xuICAgICAgICAgIGxheWVyc0NvbnRyb2xSZWYuY3VycmVudC5hZGRPdmVybGF5KG5ld0Zhcm1MYXllciwgbGF5ZXJOYW1lKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FtYWRhIGRhIGZhemVuZGEgJHtsYXllck5hbWV9IGFkaWNpb25hZGEgYW8gY29udHJvbGUgZGUgY2FtYWRhc2ApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGaXQgbWFwIHRvIGZhcm0gYm91bmRzIChvbmx5IGZvciB0aGUgZmlyc3QgS01MIGxvYWRlZCwgb3IgaWYgbm8gb3RoZXIgZmFybSBLTUwgaXMgbG9hZGVkKVxuICAgICAgICBpZiAoIWZhcm1MYXllclJlZi5jdXJyZW50KSB7IC8vIE9ubHkgZml0IGJvdW5kcyBmb3IgdGhlIGZpcnN0IGZhcm0gS01MIGxvYWRlZFxuICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IG5ld0Zhcm1MYXllci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICBpZiAoYm91bmRzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbWFwUmVmLmN1cnJlbnQuZml0Qm91bmRzKGJvdW5kcywgeyBwYWRkaW5nOiBbMjAsIDIwXSB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwYSBhanVzdGFkbyBhb3MgbGltaXRlcyBkYSBmYXplbmRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmYXJtTGF5ZXJSZWYuY3VycmVudCA9IG5ld0Zhcm1MYXllcjsgLy8gU3RvcmUgdGhlIGxhc3QgbG9hZGVkIGZhcm0gbGF5ZXJcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvIGFvIGNhcnJlZ2FyIEtNTCBkYSBmYXplbmRhICR7a21sVXJsfTpgLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgbGV0IGludGVydmFsSWQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5cbiAgICBpZiAobWFwQ29udGFpbmVyUmVmLmN1cnJlbnQgJiYgIW1hcFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBJbml0aWFsaXplIG1hcFxuICAgICAgbWFwUmVmLmN1cnJlbnQgPSBMLm1hcChtYXBDb250YWluZXJSZWYuY3VycmVudCwge1xuICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyAtLS0gRGVmaW5lIEJhc2UgTGF5ZXJzIC0tLVxuICAgICAgY29uc3Qgb3NtTGF5ZXIgPSBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICAgIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXNyaVNhdGVsbGl0ZUxheWVyID0gTC50aWxlTGF5ZXIoJ2h0dHBzOi8vc2VydmVyLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsIHtcbiAgICAgICAgYXR0cmlidXRpb246ICdUaWxlcyAmY29weTsgRXNyaSAmbWRhc2g7IFNvdXJjZTogRXNyaSwgaS1jdWJlZCwgVVNEQSwgVVNHUywgQUVYLCBHZW9FeWUsIEdldG1hcHBpbmcsIEFlcm9ncmlkLCBJR04sIElHUCwgVVBSLUVHUCwgYW5kIHRoZSBHSVMgVXNlciBDb21tdW5pdHknXG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGRlZmF1bHQgYmFzZSBsYXllciAoT1NNKVxuICAgICAgb3NtTGF5ZXIuYWRkVG8obWFwUmVmLmN1cnJlbnQpO1xuXG4gICAgICAvLyAtLS0gRGVmaW5lIE92ZXJsYXkgTGF5ZXJzIC0tLVxuICAgICAgY29uc3Qgb3ZlcmxheU1hcHMgPSB7fTsgLy8gV2lsbCBiZSBwb3B1bGF0ZWQgbGF0ZXJcblxuICAgICAgLy8gLS0tIEFkZCBMYXllcnMgQ29udHJvbCAtLS1cbiAgICAgIGNvbnN0IGJhc2VNYXBzID0ge1xuICAgICAgICBcIk9wZW5TdHJlZXRNYXBcIjogb3NtTGF5ZXIsXG4gICAgICAgIFwiU2F0w6lsaXRlIChFU1JJKVwiOiBlc3JpU2F0ZWxsaXRlTGF5ZXJcbiAgICAgIH07XG4gICAgICBsYXllcnNDb250cm9sUmVmLmN1cnJlbnQgPSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VNYXBzLCBvdmVybGF5TWFwcykuYWRkVG8obWFwUmVmLmN1cnJlbnQpO1xuXG4gICAgICAvLyBGaXggZm9yIG1hcmtlciBpY29uc1xuICAgICAgZGVsZXRlIChMLkljb24uRGVmYXVsdC5wcm90b3R5cGUgYXMgYW55KS5fZ2V0SWNvblVybDtcbiAgICAgIEwuSWNvbi5EZWZhdWx0Lm1lcmdlT3B0aW9ucyh7XG4gICAgICAgIGljb25SZXRpbmFVcmw6ICdodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLTJ4LnBuZycsXG4gICAgICAgIGljb25Vcmw6ICdodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZycsXG4gICAgICAgIHNoYWRvd1VybDogJ2h0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS45LjQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmcnLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIExvYWQgRmFybSBLTUwgZGF0YVxuICAgICAgY29uc3QgZmFybUtNTHMgPSBbXG4gICAgICAgIHsgdXJsOiBcbiAgICAgICAgICAnL2RvYy5rbWwnLCBuYW1lOiAnRmF6ZW5kYSBBdGFsYWlhJyBcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRpY2lvbmUgbWFpcyBLTUxzIGFxdWksIHBvciBleGVtcGxvOlxuICAgICAgICAvLyB7IHVybDogJy9vdXRyYV9mYXplbmRhLmttbCcsIG5hbWU6ICdPdXRyYSBGYXplbmRhJyB9LFxuICAgICAgXTtcblxuICAgICAgZmFybUtNTHMuZm9yRWFjaChmYXJtID0+IHtcbiAgICAgICAgbG9hZEZhcm1LTUwoZmFybS51cmwsIGZhcm0ubmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbCBmZXRjaCBvZiBJTlBFIEZpcmUgS01MIGRhdGFcbiAgICAgIHVwZGF0ZUZpcmVEYXRhKCk7IC8vIFRoaXMgd2lsbCBub3cgYWxzbyBhZGQgZmlyZSBsYXllcnMgdG8gdGhlIGNvbnRyb2xcblxuICAgICAgLy8gU2V0IHVwIGludGVydmFsIGZvciBwZXJpb2RpYyB1cGRhdGVzXG4gICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodXBkYXRlRmlyZURhdGEsIFJFRlJFU0hfSU5URVJWQUwpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICBpZiAoaW50ZXJ2YWxJZCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgfVxuICAgICAgLy8gT3B0aW9uYWw6IENsZWFuIHVwIG1hcCBpbnN0YW5jZSBpZiBjb21wb25lbnQgdW5tb3VudHNcbiAgICAgIC8vIGlmIChtYXBSZWYuY3VycmVudCkge1xuICAgICAgLy8gICBtYXBSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgIC8vICAgbWFwUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgLy8gfVxuICAgIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2NlbnRlciwgem9vbV0pOyAvLyBPbmx5IHJlLXJ1biBpZiBjZW50ZXIvem9vbSBwcm9wcyBjaGFuZ2VcblxuXG4gIHJldHVybiA8ZGl2IHJlZj17bWFwQ29udGFpbmVyUmVmfSBzdHlsZT17eyBoZWlnaHQ6ICcxMDB2aCcsIHdpZHRoOiAnMTAwJScgfX0gLz47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDb21wb25lbnQ7XG5cblxuXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkwiLCJET01QYXJzZXIiLCJrbWwiLCJpbnBlVXJscyIsImZpcmVJY29uIiwiaWNvbiIsImljb25VcmwiLCJpY29uU2l6ZSIsImljb25BbmNob3IiLCJwb3B1cEFuY2hvciIsIlJFRlJFU0hfSU5URVJWQUwiLCJNYXBDb21wb25lbnQiLCJjZW50ZXIiLCJ6b29tIiwibWFwQ29udGFpbmVyUmVmIiwibWFwUmVmIiwiZmlyZURhdGFMYXllcnMiLCJzZXRGaXJlRGF0YUxheWVycyIsImZhcm1MYXllclJlZiIsImxheWVyc0NvbnRyb2xSZWYiLCJmZXRjaEFuZFByb2Nlc3NGaXJlS01MIiwiaW5wZVVybCIsInByb3h5QXBpVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJrbWxUZXh0IiwidGV4dCIsInByb2Nlc3NLTUxUZXh0IiwiZXJyb3IiLCJjb25zb2xlIiwic291cmNlVXJsIiwicGFyc2VyIiwia21sRG9jIiwicGFyc2VGcm9tU3RyaW5nIiwicGFyc2VyZXJyb3JOUyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibGVuZ3RoIiwidGV4dENvbnRlbnQiLCJnZW9qc29uIiwicG9pbnRGZWF0dXJlcyIsImZlYXR1cmVzIiwiZmlsdGVyIiwiZmVhdHVyZSIsImdlb21ldHJ5IiwidHlwZSIsInBvaW50RmVhdHVyZUNvbGxlY3Rpb24iLCJsb2ciLCJnZW9KU09OIiwibGF5ZXIiLCJwb2ludFRvTGF5ZXIiLCJsYXRsbmciLCJtYXJrZXIiLCJvbkVhY2hGZWF0dXJlIiwicHJvcGVydGllcyIsInBvcHVwQ29udGVudCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImRlc2MiLCJkYXRlVGltZU1hdGNoIiwibWF0Y2giLCJzYXRlbGxpdGVNYXRjaCIsIm11bmljaXBpb01hdGNoIiwiZXN0YWRvTWF0Y2giLCJiaW5kUG9wdXAiLCJwYXJzZUVycm9yIiwidXBkYXRlRmlyZURhdGEiLCJjdXJyZW50IiwibmV3TGF5ZXJzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInVybCIsInZhbGlkTmV3TGF5ZXJzIiwiZm9yRWFjaCIsInJlbW92ZUxheWVyIiwiZmlyZUxheWVyR3JvdXAiLCJsYXllckdyb3VwIiwiYWRkTGF5ZXIiLCJhZGRPdmVybGF5IiwicmVkdWNlIiwiYWNjIiwiZ2V0TGF5ZXJzIiwibG9hZEZhcm1LTUwiLCJrbWxVcmwiLCJsYXllck5hbWUiLCJ3YXJuIiwibmV3RmFybUxheWVyIiwic3R5bGUiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJmaWxsT3BhY2l0eSIsImZpbGxDb2xvciIsInN0eWxlVXJsIiwiaW5jbHVkZXMiLCJhZGRUbyIsImJvdW5kcyIsImdldEJvdW5kcyIsImlzVmFsaWQiLCJmaXRCb3VuZHMiLCJwYWRkaW5nIiwiaXNNb3VudGVkIiwiaW50ZXJ2YWxJZCIsIm9zbUxheWVyIiwidGlsZUxheWVyIiwiYXR0cmlidXRpb24iLCJlc3JpU2F0ZWxsaXRlTGF5ZXIiLCJvdmVybGF5TWFwcyIsImJhc2VNYXBzIiwiY29udHJvbCIsImxheWVycyIsIkljb24iLCJEZWZhdWx0IiwicHJvdG90eXBlIiwiX2dldEljb25VcmwiLCJtZXJnZU9wdGlvbnMiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiZmFybUtNTHMiLCJmYXJtIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZGl2IiwicmVmIiwiaGVpZ2h0Iiwid2lkdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/MapComponent.tsx\n"));

/***/ })

});