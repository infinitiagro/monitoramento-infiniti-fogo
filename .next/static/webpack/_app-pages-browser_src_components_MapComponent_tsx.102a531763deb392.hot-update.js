"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_MapComponent_tsx",{

/***/ "(app-pages-browser)/./src/components/MapComponent.tsx":
/*!*****************************************!*\
  !*** ./src/components/MapComponent.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/.pnpm/leaflet@1.9.4/node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var xmldom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xmldom */ \"(app-pages-browser)/./node_modules/.pnpm/xmldom@0.6.0/node_modules/xmldom/lib/dom-parser.js\");\n/* harmony import */ var _tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tmcw/togeojson */ \"(app-pages-browser)/./node_modules/.pnpm/@tmcw+togeojson@7.1.1/node_modules/@tmcw/togeojson/dist/togeojson.es.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Define URLs for INPE KML data\nconst inpeUrls = [\n    'https://dataserver-coids.inpe.br/queimadas/queimadas/focos/kml/estados-48h/focos_frentes_MT.kml',\n    'https://dataserver-coids.inpe.br/queimadas/queimadas/focos/kml/estados-48h/focos_frentes_MS.kml'\n];\n// Custom icon for fire points\nconst fireIcon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().icon({\n    iconUrl: 'https://img.icons8.com/plasticine/100/fire-element--v1.png',\n    iconSize: [\n        30,\n        30\n    ],\n    iconAnchor: [\n        15,\n        30\n    ],\n    popupAnchor: [\n        0,\n        -30\n    ] // point from which the popup should open relative to the iconAnchor\n});\n// Refresh interval in milliseconds (10 minutes = 600 seconds * 1000 ms/s)\nconst REFRESH_INTERVAL = 600 * 1000;\nconst MapComponent = (param)=>{\n    let { center, zoom } = param;\n    _s();\n    const mapContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [fireDataLayers, setFireDataLayers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const farmLayerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref to store farm layer\n    const layersControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref for layers control\n    // Function to fetch and process KML data (for fire points) via internal API proxy\n    const fetchAndProcessFireKML = async (inpeUrl)=>{\n        try {\n            // Use the internal API route as a proxy\n            const proxyApiUrl = \"/api/inpe-kml?url=\".concat(encodeURIComponent(inpeUrl));\n            const response = await fetch(proxyApiUrl);\n            if (!response.ok) {\n                throw new Error(\"Erro no proxy interno! status: \".concat(response.status, \" para \").concat(inpeUrl));\n            }\n            const kmlText = await response.text();\n            return processKMLText(kmlText, inpeUrl);\n        } catch (error) {\n            console.error(\"Erro ao buscar ou processar KML de \".concat(inpeUrl, \" via proxy interno:\"), error);\n            return null;\n        }\n    };\n    // Helper function to process KML text into GeoJSON layer\n    const processKMLText = (kmlText, sourceUrl)=>{\n        try {\n            const parser = new xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n            const kmlDoc = parser.parseFromString(kmlText, 'text/xml');\n            // Check for parser errors\n            const parsererrorNS = kmlDoc.getElementsByTagName(\"parsererror\");\n            if (parsererrorNS.length > 0) {\n                console.error(\"Erro de parsing KML de \".concat(sourceUrl, \":\"), parsererrorNS[0].textContent);\n                throw new Error('Erro de parsing KML');\n            }\n            const geojson = (0,_tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__.kml)(kmlDoc); // Assuming fire data are points\n            // Filter out non-point features if necessary\n            const pointFeatures = geojson.features.filter((feature)=>{\n                var _feature_geometry;\n                return ((_feature_geometry = feature.geometry) === null || _feature_geometry === void 0 ? void 0 : _feature_geometry.type) === 'Point';\n            });\n            const pointFeatureCollection = {\n                type: 'FeatureCollection',\n                features: pointFeatures\n            };\n            if (pointFeatures.length === 0) {\n                console.log(\"Nenhum foco de inc\\xeandio (ponto) encontrado em \".concat(sourceUrl));\n                // Return an empty layer group instead of null to avoid issues in Promise.all\n                return leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON();\n            }\n            const layer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(pointFeatureCollection, {\n                pointToLayer: (feature, latlng)=>{\n                    return leaflet__WEBPACK_IMPORTED_MODULE_2___default().marker(latlng, {\n                        icon: fireIcon\n                    });\n                },\n                onEachFeature: (feature, layer)=>{\n                    if (feature.properties) {\n                        let popupContent = \"<b>\".concat(feature.properties.name || 'Foco de Incêndio', \"</b>\");\n                        if (feature.properties.description) {\n                            const desc = feature.properties.description;\n                            // Extract specific fields from the description table\n                            const dateTimeMatch = desc.match(/<td>Data Hora UTC<\\/td><td>([^<]+)<\\/td>/);\n                            const satelliteMatch = desc.match(/<td>Satélite<\\/td><td>([^<]+)<\\/td>/);\n                            const municipioMatch = desc.match(/<td>Município<\\/td><td>([^<]+)<\\/td>/);\n                            const estadoMatch = desc.match(/<td>Estado<\\/td><td>([^<]+)<\\/td>/);\n                            if (dateTimeMatch === null || dateTimeMatch === void 0 ? void 0 : dateTimeMatch[1]) popupContent += \"<br/>Data/Hora: \".concat(dateTimeMatch[1]);\n                            if (satelliteMatch === null || satelliteMatch === void 0 ? void 0 : satelliteMatch[1]) popupContent += \"<br/>Sat\\xe9lite: \".concat(satelliteMatch[1]);\n                            if (municipioMatch === null || municipioMatch === void 0 ? void 0 : municipioMatch[1]) popupContent += \"<br/>Munic\\xedpio: \".concat(municipioMatch[1]);\n                            if (estadoMatch === null || estadoMatch === void 0 ? void 0 : estadoMatch[1]) popupContent += \"<br/>Estado: \".concat(estadoMatch[1]);\n                        }\n                        layer.bindPopup(popupContent);\n                    }\n                }\n            });\n            return layer;\n        } catch (parseError) {\n            console.error(\"Erro ao processar KML de \".concat(sourceUrl, \":\"), parseError);\n            return null; // Return null on error\n        }\n    };\n    // Function to update fire data\n    const updateFireData = async ()=>{\n        var _mapRef_current;\n        if (!mapRef.current) return;\n        console.log('Atualizando dados de incêndio via proxy interno...');\n        const newLayers = await Promise.all(inpeUrls.map((url)=>fetchAndProcessFireKML(url)));\n        const validNewLayers = newLayers.filter((layer)=>layer !== null);\n        // Remove old layers from map and control\n        fireDataLayers.forEach((layer)=>{\n            var _mapRef_current;\n            (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.removeLayer(layer);\n            if (layersControlRef.current) {\n                layersControlRef.current.removeLayer(layer);\n            }\n        });\n        // Add new layers to map and control\n        const fireLayerGroup = leaflet__WEBPACK_IMPORTED_MODULE_2___default().layerGroup(validNewLayers);\n        (_mapRef_current = mapRef.current) === null || _mapRef_current === void 0 ? void 0 : _mapRef_current.addLayer(fireLayerGroup);\n        if (layersControlRef.current) {\n            layersControlRef.current.addOverlay(fireLayerGroup, \"Focos de Incêndio (INPE)\");\n        }\n        // Update state\n        setFireDataLayers(validNewLayers); // Store individual layers for removal later\n        console.log(\"Dados de inc\\xeandio atualizados. \".concat(validNewLayers.reduce((acc, layer)=>acc + layer.getLayers().length, 0), \" focos carregados.\"));\n    };\n    // Function to load and process farm KML data\n    const loadFarmKML = async (kmlUrl, layerName)=>{\n        try {\n            console.log(\"Carregando dados KML da fazenda de \".concat(kmlUrl, \"...\"));\n            const response = await fetch(kmlUrl);\n            if (!response.ok) {\n                throw new Error(\"Erro ao carregar KML da fazenda! Status: \".concat(response.status));\n            }\n            const kmlText = await response.text();\n            console.log(\"KML da fazenda carregado com sucesso, processando...\");\n            const parser = new xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n            const kmlDoc = parser.parseFromString(kmlText, \"text/xml\");\n            // Check for parser errors\n            const parsererrorNS = kmlDoc.getElementsByTagName(\"parsererror\");\n            if (parsererrorNS.length > 0) {\n                console.error(\"Erro de parsing KML da fazenda:\", parsererrorNS[0].textContent);\n                throw new Error(\"Erro de parsing KML da fazenda\");\n            }\n            const geojson = (0,_tmcw_togeojson__WEBPACK_IMPORTED_MODULE_5__.kml)(kmlDoc);\n            console.log(\"GeoJSON processado:\", geojson);\n            if (!geojson || !geojson.features || geojson.features.length === 0) {\n                console.warn(\"Nenhuma feature encontrada no KML da fazenda\");\n                return;\n            }\n            const newFarmLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().geoJSON(geojson, {\n                style: function(feature) {\n                    var _feature_properties;\n                    let style = {\n                        color: \"#ff0000\",\n                        weight: 3,\n                        opacity: 0.8,\n                        fillOpacity: 0.2,\n                        fillColor: \"#ff0000\"\n                    };\n                    // Aplicar estilos baseados no styleUrl se disponível\n                    if (feature === null || feature === void 0 ? void 0 : (_feature_properties = feature.properties) === null || _feature_properties === void 0 ? void 0 : _feature_properties.styleUrl) {\n                        if (feature.properties.styleUrl.includes(\"PolyStyle007\")) {\n                            style.color = \"#00ffff\";\n                            style.fillColor = \"#00ffff\";\n                            style.fillOpacity = 0.1;\n                            style.weight = 2;\n                        } else if (feature.properties.styleUrl.includes(\"PolyStyle0012\")) {\n                            style.color = \"#fcb4d4\";\n                            style.fillColor = \"#fcb4d4\";\n                            style.fillOpacity = 0.1;\n                            style.weight = 2;\n                        } else if (feature.properties.styleUrl.includes(\"PolyStyle00159\")) {\n                            // Estilo do KML fornecido\n                            style.color = \"#f0f0f0\";\n                            style.fillColor = \"#f0f0f0\";\n                            style.fillOpacity = 0.07;\n                            style.weight = 3;\n                        }\n                    }\n                    return style;\n                },\n                onEachFeature: function(feature, layer) {\n                    let popupContent = feature.properties && feature.properties.name ? \"<b>\".concat(feature.properties.name, \"</b>\") : \"<b>Perímetro da Fazenda</b>\";\n                    layer.bindPopup(popupContent);\n                }\n            });\n            if (mapRef.current) {\n                newFarmLayer.addTo(mapRef.current);\n                console.log(\"Camada da fazenda \".concat(layerName, \" adicionada ao mapa\"));\n                // Add farm layer to the control\n                if (layersControlRef.current) {\n                    layersControlRef.current.addOverlay(newFarmLayer, layerName);\n                    console.log(\"Camada da fazenda \".concat(layerName, \" adicionada ao controle de camadas\"));\n                }\n                // Fit map to farm bounds (only for the first KML loaded, or if no other farm KML is loaded)\n                if (!farmLayerRef.current) {\n                    const bounds = newFarmLayer.getBounds();\n                    if (bounds.isValid()) {\n                        mapRef.current.fitBounds(bounds, {\n                            padding: [\n                                20,\n                                20\n                            ]\n                        });\n                        console.log(\"Mapa ajustado aos limites da fazenda\");\n                    }\n                }\n                farmLayerRef.current = newFarmLayer; // Store the last loaded farm layer\n            }\n        } catch (error) {\n            console.error(\"Erro ao carregar KML da fazenda \".concat(kmlUrl, \":\"), error);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MapComponent.useEffect\": ()=>{\n            let isMounted = true;\n            let intervalId = null;\n            if (mapContainerRef.current && !mapRef.current) {\n                // Initialize map\n                mapRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().map(mapContainerRef.current, {\n                    center: center,\n                    zoom: zoom\n                });\n                // --- Define Base Layers ---\n                const osmLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n                });\n                const esriSatelliteLayer = leaflet__WEBPACK_IMPORTED_MODULE_2___default().tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {\n                    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'\n                });\n                // Add default base layer (OSM)\n                osmLayer.addTo(mapRef.current);\n                // --- Define Overlay Layers ---\n                const overlayMaps = {}; // Will be populated later\n                // --- Add Layers Control ---\n                const baseMaps = {\n                    \"OpenStreetMap\": osmLayer,\n                    \"Satélite (ESRI)\": esriSatelliteLayer\n                };\n                layersControlRef.current = leaflet__WEBPACK_IMPORTED_MODULE_2___default().control.layers(baseMaps, overlayMaps).addTo(mapRef.current);\n                // Fix for marker icons\n                delete (leaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon).Default.prototype._getIconUrl;\n                leaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon.Default.mergeOptions({\n                    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',\n                    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',\n                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png'\n                });\n                // Load Farm KML data\n                const farmKMLs = [\n                    {\n                        url: '/doc.kml',\n                        name: 'Fazenda Atalaia'\n                    }\n                ];\n                farmKMLs.forEach({\n                    \"MapComponent.useEffect\": (farm)=>{\n                        loadFarmKML(farm.url, farm.name);\n                    }\n                }[\"MapComponent.useEffect\"]);\n                // Initial fetch of INPE Fire KML data\n                updateFireData(); // This will now also add fire layers to the control\n                // Set up interval for periodic updates\n                intervalId = setInterval(updateFireData, REFRESH_INTERVAL);\n            }\n            // Cleanup function\n            return ({\n                \"MapComponent.useEffect\": ()=>{\n                    isMounted = false;\n                    if (intervalId) {\n                        clearInterval(intervalId);\n                    }\n                // Optional: Clean up map instance if component unmounts\n                // if (mapRef.current) {\n                //   mapRef.current.remove();\n                //   mapRef.current = null;\n                // }\n                }\n            })[\"MapComponent.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"MapComponent.useEffect\"], [\n        center,\n        zoom\n    ]); // Only re-run if center/zoom props change\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapContainerRef,\n        style: {\n            height: '100vh',\n            width: '100%'\n        }\n    }, void 0, false, {\n        fileName: \"D:\\\\Aplicativo_monitoramento de incendios\\\\fire_monitor_app_backup\\\\webapp\\\\src\\\\components\\\\MapComponent.tsx\",\n        lineNumber: 314,\n        columnNumber: 10\n    }, undefined);\n};\n_s(MapComponent, \"K+oeeKqUn14Zt1fH14kWfUl7bbM=\");\n_c = MapComponent;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapComponent);\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL01hcENvbXBvbmVudC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkQ7QUFDbkM7QUFDVTtBQUNDO0FBQ0c7QUFRdEMsZ0NBQWdDO0FBQ2hDLE1BQU1PLFdBQVc7SUFDZjtJQUNBO0NBR0Q7QUFFRCw4QkFBOEI7QUFDOUIsTUFBTUMsV0FBV0osbURBQU0sQ0FBQztJQUNwQk0sU0FBUztJQUNUQyxVQUFVO1FBQUM7UUFBSTtLQUFHO0lBQ2xCQyxZQUFZO1FBQUM7UUFBSTtLQUFHO0lBQ3BCQyxhQUFhO1FBQUM7UUFBRyxDQUFDO0tBQUcsQ0FBQyxvRUFBb0U7QUFDOUY7QUFFQSwwRUFBMEU7QUFDMUUsTUFBTUMsbUJBQW1CLE1BQU07QUFFL0IsTUFBTUMsZUFBNEM7UUFBQyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRTs7SUFDakUsTUFBTUMsa0JBQWtCaEIsNkNBQU1BLENBQWlCO0lBQy9DLE1BQU1pQixTQUFTakIsNkNBQU1BLENBQWU7SUFDcEMsTUFBTSxDQUFDa0IsZ0JBQWdCQyxrQkFBa0IsR0FBR2xCLCtDQUFRQSxDQUFjLEVBQUU7SUFDcEUsTUFBTW1CLGVBQWVwQiw2Q0FBTUEsQ0FBbUIsT0FBTywwQkFBMEI7SUFDL0UsTUFBTXFCLG1CQUFtQnJCLDZDQUFNQSxDQUEwQixPQUFPLHlCQUF5QjtJQUV6RixrRkFBa0Y7SUFDbEYsTUFBTXNCLHlCQUF5QixPQUFPQztRQUNwQyxJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU1DLGNBQWMscUJBQWlELE9BQTVCQyxtQkFBbUJGO1lBQzVELE1BQU1HLFdBQVcsTUFBTUMsTUFBTUg7WUFFN0IsSUFBSSxDQUFDRSxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSxrQ0FBMEROLE9BQXhCRyxTQUFTSSxNQUFNLEVBQUMsVUFBZ0IsT0FBUlA7WUFDNUU7WUFDQSxNQUFNUSxVQUFVLE1BQU1MLFNBQVNNLElBQUk7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QUFPO2dCQUV2Rix1QkFBdUI7Z0JBQ3ZCLE9BQU8scURBQU8sQ0FBQzhDLE9BQU8sQ0FBQ0MsU0FBUyxDQUFTQyxXQUFXO2dCQUNwRHRILG1EQUFNLENBQUNvSCxPQUFPLENBQUNHLFlBQVksQ0FBQztvQkFDMUJDLGVBQWU7b0JBQ2ZsSCxTQUFTO29CQUNUbUgsV0FBVztnQkFDYjtnQkFFQSxxQkFBcUI7Z0JBQ3JCLE1BQU1DLFdBQVc7b0JBQ2Y7d0JBQUUvQyxLQUNBO3dCQUFZaEIsTUFBTTtvQkFDcEI7aUJBR0Q7Z0JBRUQrRCxTQUFTN0MsT0FBTzs4Q0FBQzhDLENBQUFBO3dCQUNmckMsWUFBWXFDLEtBQUtoRCxHQUFHLEVBQUVnRCxLQUFLaEUsSUFBSTtvQkFDakM7O2dCQUVBLHNDQUFzQztnQkFDdENVLGtCQUFrQixvREFBb0Q7Z0JBRXRFLHVDQUF1QztnQkFDdkNxQyxhQUFha0IsWUFBWXZELGdCQUFnQjNEO1lBQzNDO1lBRUEsbUJBQW1CO1lBQ25COzBDQUFPO29CQUNMK0YsWUFBWTtvQkFDWixJQUFJQyxZQUFZO3dCQUNkbUIsY0FBY25CO29CQUNoQjtnQkFDQSx3REFBd0Q7Z0JBQ3hELHdCQUF3QjtnQkFDeEIsNkJBQTZCO2dCQUM3QiwyQkFBMkI7Z0JBQzNCLElBQUk7Z0JBQ047O1FBQ0YsdURBQXVEO1FBQ3ZEO2lDQUFHO1FBQUM5RjtRQUFRQztLQUFLLEdBQUcsMENBQTBDO0lBRzlELHFCQUFPLDhEQUFDaUg7UUFBSUMsS0FBS2pIO1FBQWlCNkUsT0FBTztZQUFFcUMsUUFBUTtZQUFTQyxPQUFPO1FBQU87Ozs7OztBQUM1RTtHQTNSTXRIO0tBQUFBO0FBNlJOLGlFQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJEOlxcQXBsaWNhdGl2b19tb25pdG9yYW1lbnRvIGRlIGluY2VuZGlvc1xcZmlyZV9tb25pdG9yX2FwcF9iYWNrdXBcXHdlYmFwcFxcc3JjXFxjb21wb25lbnRzXFxNYXBDb21wb25lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcbmltcG9ydCAnbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzJztcbmltcG9ydCB7IERPTVBhcnNlciB9IGZyb20gJ3htbGRvbSc7XG5pbXBvcnQgeyBrbWwgfSBmcm9tICdAdG1jdy90b2dlb2pzb24nO1xuaW1wb3J0IHR5cGUgeyBGZWF0dXJlQ29sbGVjdGlvbiwgUG9pbnQgfSBmcm9tICdnZW9qc29uJztcblxuaW50ZXJmYWNlIE1hcENvbXBvbmVudFByb3BzIHtcbiAgY2VudGVyOiBbbnVtYmVyLCBudW1iZXJdO1xuICB6b29tOiBudW1iZXI7XG59XG5cbi8vIERlZmluZSBVUkxzIGZvciBJTlBFIEtNTCBkYXRhXG5jb25zdCBpbnBlVXJscyA9IFtcbiAgJ2h0dHBzOi8vZGF0YXNlcnZlci1jb2lkcy5pbnBlLmJyL3F1ZWltYWRhcy9xdWVpbWFkYXMvZm9jb3Mva21sL2VzdGFkb3MtNDhoL2ZvY29zX2ZyZW50ZXNfTVQua21sJyxcbiAgJ2h0dHBzOi8vZGF0YXNlcnZlci1jb2lkcy5pbnBlLmJyL3F1ZWltYWRhcy9xdWVpbWFkYXMvZm9jb3Mva21sL2VzdGFkb3MtNDhoL2ZvY29zX2ZyZW50ZXNfTVMua21sJyxcbiAgLy8naHR0cHM6Ly9kYXRhc2VydmVyLWNvaWRzLmlucGUuYnIvcXVlaW1hZGFzL3F1ZWltYWRhcy9mb2Nvcy9rbWwvZXN0YWRvcy00OGgvZm9jb3NfZnJlbnRlc19CQS5rbWwnLFxuICAvLydodHRwczovL2RhdGFzZXJ2ZXItY29pZHMuaW5wZS5ici9xdWVpbWFkYXMvcXVlaW1hZGFzL2ZvY29zL2ttbC9lc3RhZG9zLTQ4aC9mb2Nvc19mcmVudGVzX01BLmttbCdcbl07XG5cbi8vIEN1c3RvbSBpY29uIGZvciBmaXJlIHBvaW50c1xuY29uc3QgZmlyZUljb24gPSBMLmljb24oe1xuICAgIGljb25Vcmw6ICdodHRwczovL2ltZy5pY29uczguY29tL3BsYXN0aWNpbmUvMTAwL2ZpcmUtZWxlbWVudC0tdjEucG5nJywgLy8gVXNpbmcgYSBwbGFjZWhvbGRlciBpY29uXG4gICAgaWNvblNpemU6IFszMCwgMzBdLCAvLyBzaXplIG9mIHRoZSBpY29uXG4gICAgaWNvbkFuY2hvcjogWzE1LCAzMF0sIC8vIHBvaW50IG9mIHRoZSBpY29uIHdoaWNoIHdpbGwgY29ycmVzcG9uZCB0byBtYXJrZXIncyBsb2NhdGlvblxuICAgIHBvcHVwQW5jaG9yOiBbMCwgLTMwXSAvLyBwb2ludCBmcm9tIHdoaWNoIHRoZSBwb3B1cCBzaG91bGQgb3BlbiByZWxhdGl2ZSB0byB0aGUgaWNvbkFuY2hvclxufSk7XG5cbi8vIFJlZnJlc2ggaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzICgxMCBtaW51dGVzID0gNjAwIHNlY29uZHMgKiAxMDAwIG1zL3MpXG5jb25zdCBSRUZSRVNIX0lOVEVSVkFMID0gNjAwICogMTAwMDtcblxuY29uc3QgTWFwQ29tcG9uZW50OiBSZWFjdC5GQzxNYXBDb21wb25lbnRQcm9wcz4gPSAoeyBjZW50ZXIsIHpvb20gfSkgPT4ge1xuICBjb25zdCBtYXBDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8TC5NYXAgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2ZpcmVEYXRhTGF5ZXJzLCBzZXRGaXJlRGF0YUxheWVyc10gPSB1c2VTdGF0ZTxMLkdlb0pTT05bXT4oW10pO1xuICBjb25zdCBmYXJtTGF5ZXJSZWYgPSB1c2VSZWY8TC5HZW9KU09OIHwgbnVsbD4obnVsbCk7IC8vIFJlZiB0byBzdG9yZSBmYXJtIGxheWVyXG4gIGNvbnN0IGxheWVyc0NvbnRyb2xSZWYgPSB1c2VSZWY8TC5Db250cm9sLkxheWVycyB8IG51bGw+KG51bGwpOyAvLyBSZWYgZm9yIGxheWVycyBjb250cm9sXG5cbiAgLy8gRnVuY3Rpb24gdG8gZmV0Y2ggYW5kIHByb2Nlc3MgS01MIGRhdGEgKGZvciBmaXJlIHBvaW50cykgdmlhIGludGVybmFsIEFQSSBwcm94eVxuICBjb25zdCBmZXRjaEFuZFByb2Nlc3NGaXJlS01MID0gYXN5bmMgKGlucGVVcmw6IHN0cmluZyk6IFByb21pc2U8TC5HZW9KU09OIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgdGhlIGludGVybmFsIEFQSSByb3V0ZSBhcyBhIHByb3h5XG4gICAgICBjb25zdCBwcm94eUFwaVVybCA9IGAvYXBpL2lucGUta21sP3VybD0ke2VuY29kZVVSSUNvbXBvbmVudChpbnBlVXJsKX1gO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChwcm94eUFwaVVybCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIG5vIHByb3h5IGludGVybm8hIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9IHBhcmEgJHtpbnBlVXJsfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qga21sVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiBwcm9jZXNzS01MVGV4dChrbWxUZXh0LCBpbnBlVXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJybyBhbyBidXNjYXIgb3UgcHJvY2Vzc2FyIEtNTCBkZSAke2lucGVVcmx9IHZpYSBwcm94eSBpbnRlcm5vOmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcHJvY2VzcyBLTUwgdGV4dCBpbnRvIEdlb0pTT04gbGF5ZXJcbiAgY29uc3QgcHJvY2Vzc0tNTFRleHQgPSAoa21sVGV4dDogc3RyaW5nLCBzb3VyY2VVcmw6IHN0cmluZyk6IEwuR2VvSlNPTiB8IG51bGwgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgY29uc3Qga21sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhrbWxUZXh0LCAndGV4dC94bWwnKTtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgcGFyc2VyIGVycm9yc1xuICAgICAgICAgIGNvbnN0IHBhcnNlcmVycm9yTlMgPSBrbWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKTtcbiAgICAgICAgICBpZiAocGFyc2VyZXJyb3JOUy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm8gZGUgcGFyc2luZyBLTUwgZGUgJHtzb3VyY2VVcmx9OmAsIHBhcnNlcmVycm9yTlNbMF0udGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm8gZGUgcGFyc2luZyBLTUwnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBnZW9qc29uID0ga21sKGttbERvYykgYXMgRmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+OyAvLyBBc3N1bWluZyBmaXJlIGRhdGEgYXJlIHBvaW50c1xuXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBub24tcG9pbnQgZmVhdHVyZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgY29uc3QgcG9pbnRGZWF0dXJlcyA9IGdlb2pzb24uZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS5nZW9tZXRyeT8udHlwZSA9PT0gJ1BvaW50Jyk7XG4gICAgICAgICAgY29uc3QgcG9pbnRGZWF0dXJlQ29sbGVjdGlvbjogRmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+ID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICBmZWF0dXJlczogcG9pbnRGZWF0dXJlcyBhcyBhbnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHBvaW50RmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBOZW5odW0gZm9jbyBkZSBpbmPDqm5kaW8gKHBvbnRvKSBlbmNvbnRyYWRvIGVtICR7c291cmNlVXJsfWApO1xuICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgbGF5ZXIgZ3JvdXAgaW5zdGVhZCBvZiBudWxsIHRvIGF2b2lkIGlzc3VlcyBpbiBQcm9taXNlLmFsbFxuICAgICAgICAgICAgICByZXR1cm4gTC5nZW9KU09OKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGF5ZXIgPSBMLmdlb0pTT04ocG9pbnRGZWF0dXJlQ29sbGVjdGlvbiBhcyBhbnksIHtcbiAgICAgICAgICAgIHBvaW50VG9MYXllcjogKGZlYXR1cmUsIGxhdGxuZykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gTC5tYXJrZXIobGF0bG5nLCB7IGljb246IGZpcmVJY29uIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRWFjaEZlYXR1cmU6IChmZWF0dXJlLCBsYXllcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcHVwQ29udGVudCA9IGA8Yj4ke2ZlYXR1cmUucHJvcGVydGllcy5uYW1lIHx8ICdGb2NvIGRlIEluY8OqbmRpbyd9PC9iPmA7XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNwZWNpZmljIGZpZWxkcyBmcm9tIHRoZSBkZXNjcmlwdGlvbiB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlVGltZU1hdGNoID0gZGVzYy5tYXRjaCgvPHRkPkRhdGEgSG9yYSBVVEM8XFwvdGQ+PHRkPihbXjxdKyk8XFwvdGQ+Lyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhdGVsbGl0ZU1hdGNoID0gZGVzYy5tYXRjaCgvPHRkPlNhdMOpbGl0ZTxcXC90ZD48dGQ+KFtePF0rKTxcXC90ZD4vKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVuaWNpcGlvTWF0Y2ggPSBkZXNjLm1hdGNoKC88dGQ+TXVuaWPDrXBpbzxcXC90ZD48dGQ+KFtePF0rKTxcXC90ZD4vKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXN0YWRvTWF0Y2ggPSBkZXNjLm1hdGNoKC88dGQ+RXN0YWRvPFxcL3RkPjx0ZD4oW148XSspPFxcL3RkPi8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlVGltZU1hdGNoPy5bMV0pIHBvcHVwQ29udGVudCArPSBgPGJyLz5EYXRhL0hvcmE6ICR7ZGF0ZVRpbWVNYXRjaFsxXX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2F0ZWxsaXRlTWF0Y2g/LlsxXSkgcG9wdXBDb250ZW50ICs9IGA8YnIvPlNhdMOpbGl0ZTogJHtzYXRlbGxpdGVNYXRjaFsxXX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVuaWNpcGlvTWF0Y2g/LlsxXSkgcG9wdXBDb250ZW50ICs9IGA8YnIvPk11bmljw61waW86ICR7bXVuaWNpcGlvTWF0Y2hbMV19YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzdGFkb01hdGNoPy5bMV0pIHBvcHVwQ29udGVudCArPSBgPGJyLz5Fc3RhZG86ICR7ZXN0YWRvTWF0Y2hbMV19YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJybyBhbyBwcm9jZXNzYXIgS01MIGRlICR7c291cmNlVXJsfTpgLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gUmV0dXJuIG51bGwgb24gZXJyb3JcbiAgICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBmaXJlIGRhdGFcbiAgY29uc3QgdXBkYXRlRmlyZURhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKCdBdHVhbGl6YW5kbyBkYWRvcyBkZSBpbmPDqm5kaW8gdmlhIHByb3h5IGludGVybm8uLi4nKTtcbiAgICBjb25zdCBuZXdMYXllcnMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnBlVXJscy5tYXAodXJsID0+IGZldGNoQW5kUHJvY2Vzc0ZpcmVLTUwodXJsKSkpO1xuICAgIGNvbnN0IHZhbGlkTmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllciAhPT0gbnVsbCkgYXMgTC5HZW9KU09OW107XG5cbiAgICAvLyBSZW1vdmUgb2xkIGxheWVycyBmcm9tIG1hcCBhbmQgY29udHJvbFxuICAgIGZpcmVEYXRhTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICBtYXBSZWYuY3VycmVudD8ucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBpZiAobGF5ZXJzQ29udHJvbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBsYXllcnNDb250cm9sUmVmLmN1cnJlbnQucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgbmV3IGxheWVycyB0byBtYXAgYW5kIGNvbnRyb2xcbiAgICBjb25zdCBmaXJlTGF5ZXJHcm91cCA9IEwubGF5ZXJHcm91cCh2YWxpZE5ld0xheWVycyk7XG4gICAgbWFwUmVmLmN1cnJlbnQ/LmFkZExheWVyKGZpcmVMYXllckdyb3VwKTtcbiAgICBpZiAobGF5ZXJzQ29udHJvbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxheWVyc0NvbnRyb2xSZWYuY3VycmVudC5hZGRPdmVybGF5KGZpcmVMYXllckdyb3VwLCBcIkZvY29zIGRlIEluY8OqbmRpbyAoSU5QRSlcIik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgc2V0RmlyZURhdGFMYXllcnModmFsaWROZXdMYXllcnMpOyAvLyBTdG9yZSBpbmRpdmlkdWFsIGxheWVycyBmb3IgcmVtb3ZhbCBsYXRlclxuICAgIGNvbnNvbGUubG9nKGBEYWRvcyBkZSBpbmPDqm5kaW8gYXR1YWxpemFkb3MuICR7dmFsaWROZXdMYXllcnMucmVkdWNlKChhY2MsIGxheWVyKSA9PiBhY2MgKyBsYXllci5nZXRMYXllcnMoKS5sZW5ndGgsIDApfSBmb2NvcyBjYXJyZWdhZG9zLmApO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGxvYWQgYW5kIHByb2Nlc3MgZmFybSBLTUwgZGF0YVxuICBjb25zdCBsb2FkRmFybUtNTCA9IGFzeW5jIChrbWxVcmw6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYENhcnJlZ2FuZG8gZGFkb3MgS01MIGRhIGZhemVuZGEgZGUgJHtrbWxVcmx9Li4uYCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGttbFVybCk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIGFvIGNhcnJlZ2FyIEtNTCBkYSBmYXplbmRhISBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBrbWxUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5sb2coXCJLTUwgZGEgZmF6ZW5kYSBjYXJyZWdhZG8gY29tIHN1Y2Vzc28sIHByb2Nlc3NhbmRvLi4uXCIpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBjb25zdCBrbWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGttbFRleHQsIFwidGV4dC94bWxcIik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwYXJzZXIgZXJyb3JzXG4gICAgICBjb25zdCBwYXJzZXJlcnJvck5TID0ga21sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIik7XG4gICAgICBpZiAocGFyc2VyZXJyb3JOUy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGRlIHBhcnNpbmcgS01MIGRhIGZhemVuZGE6XCIsIHBhcnNlcmVycm9yTlNbMF0udGV4dENvbnRlbnQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvIGRlIHBhcnNpbmcgS01MIGRhIGZhemVuZGFcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGdlb2pzb24gPSBrbWwoa21sRG9jKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiR2VvSlNPTiBwcm9jZXNzYWRvOlwiLCBnZW9qc29uKTtcblxuICAgICAgaWYgKCFnZW9qc29uIHx8ICFnZW9qc29uLmZlYXR1cmVzIHx8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5lbmh1bWEgZmVhdHVyZSBlbmNvbnRyYWRhIG5vIEtNTCBkYSBmYXplbmRhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0Zhcm1MYXllciA9IEwuZ2VvSlNPTihnZW9qc29uIGFzIGFueSwge1xuICAgICAgICBzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICBsZXQgc3R5bGU6IEwuUGF0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb2xvcjogXCIjZmYwMDAwXCIsIC8vIENvciB2ZXJtZWxoYSBwYWRyw6NvIHBhcmEgbWVsaG9yIHZpc2liaWxpZGFkZVxuICAgICAgICAgICAgd2VpZ2h0OiAzLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOCwgXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBcIiNmZjAwMDBcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBsaWNhciBlc3RpbG9zIGJhc2VhZG9zIG5vIHN0eWxlVXJsIHNlIGRpc3BvbsOtdmVsXG4gICAgICAgICAgaWYgKGZlYXR1cmU/LnByb3BlcnRpZXM/LnN0eWxlVXJsKSB7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlVXJsLmluY2x1ZGVzKFwiUG9seVN0eWxlMDA3XCIpKSB7IFxuICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IFwiIzAwZmZmZlwiOyBcbiAgICAgICAgICAgICAgc3R5bGUuZmlsbENvbG9yID0gXCIjMDBmZmZmXCI7XG4gICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gMC4xOyBcbiAgICAgICAgICAgICAgc3R5bGUud2VpZ2h0ID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlVXJsLmluY2x1ZGVzKFwiUG9seVN0eWxlMDAxMlwiKSkgeyBcbiAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSBcIiNmY2I0ZDRcIjsgXG4gICAgICAgICAgICAgIHN0eWxlLmZpbGxDb2xvciA9IFwiI2ZjYjRkNFwiO1xuICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IDAuMTsgXG4gICAgICAgICAgICAgIHN0eWxlLndlaWdodCA9IDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUucHJvcGVydGllcy5zdHlsZVVybC5pbmNsdWRlcyhcIlBvbHlTdHlsZTAwMTU5XCIpKSB7XG4gICAgICAgICAgICAgIC8vIEVzdGlsbyBkbyBLTUwgZm9ybmVjaWRvXG4gICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gXCIjZjBmMGYwXCI7XG4gICAgICAgICAgICAgIHN0eWxlLmZpbGxDb2xvciA9IFwiI2YwZjBmMFwiO1xuICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IDAuMDc7XG4gICAgICAgICAgICAgIHN0eWxlLndlaWdodCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FYWNoRmVhdHVyZTogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgICAgICAgbGV0IHBvcHVwQ29udGVudCA9IGZlYXR1cmUucHJvcGVydGllcyAmJiBmZWF0dXJlLnByb3BlcnRpZXMubmFtZSA/IGA8Yj4ke2ZlYXR1cmUucHJvcGVydGllcy5uYW1lfTwvYj5gIDogXCI8Yj5QZXLDrW1ldHJvIGRhIEZhemVuZGE8L2I+XCI7XG4gICAgICAgICAgbGF5ZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWFwUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbmV3RmFybUxheWVyLmFkZFRvKG1hcFJlZi5jdXJyZW50KTtcbiAgICAgICAgY29uc29sZS5sb2coYENhbWFkYSBkYSBmYXplbmRhICR7bGF5ZXJOYW1lfSBhZGljaW9uYWRhIGFvIG1hcGFgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBmYXJtIGxheWVyIHRvIHRoZSBjb250cm9sXG4gICAgICAgIGlmIChsYXllcnNDb250cm9sUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBsYXllcnNDb250cm9sUmVmLmN1cnJlbnQuYWRkT3ZlcmxheShuZXdGYXJtTGF5ZXIsIGxheWVyTmFtZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYENhbWFkYSBkYSBmYXplbmRhICR7bGF5ZXJOYW1lfSBhZGljaW9uYWRhIGFvIGNvbnRyb2xlIGRlIGNhbWFkYXNgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRml0IG1hcCB0byBmYXJtIGJvdW5kcyAob25seSBmb3IgdGhlIGZpcnN0IEtNTCBsb2FkZWQsIG9yIGlmIG5vIG90aGVyIGZhcm0gS01MIGlzIGxvYWRlZClcbiAgICAgICAgaWYgKCFmYXJtTGF5ZXJSZWYuY3VycmVudCkgeyAvLyBPbmx5IGZpdCBib3VuZHMgZm9yIHRoZSBmaXJzdCBmYXJtIEtNTCBsb2FkZWRcbiAgICAgICAgICBjb25zdCBib3VuZHMgPSBuZXdGYXJtTGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgaWYgKGJvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1hcFJlZi5jdXJyZW50LmZpdEJvdW5kcyhib3VuZHMsIHsgcGFkZGluZzogWzIwLCAyMF0gfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcGEgYWp1c3RhZG8gYW9zIGxpbWl0ZXMgZGEgZmF6ZW5kYVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmFybUxheWVyUmVmLmN1cnJlbnQgPSBuZXdGYXJtTGF5ZXI7IC8vIFN0b3JlIHRoZSBsYXN0IGxvYWRlZCBmYXJtIGxheWVyXG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJybyBhbyBjYXJyZWdhciBLTUwgZGEgZmF6ZW5kYSAke2ttbFVybH06YCwgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIGxldCBpbnRlcnZhbElkOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXG4gICAgaWYgKG1hcENvbnRhaW5lclJlZi5jdXJyZW50ICYmICFtYXBSZWYuY3VycmVudCkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBtYXBcbiAgICAgIG1hcFJlZi5jdXJyZW50ID0gTC5tYXAobWFwQ29udGFpbmVyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICB9KTtcblxuICAgICAgLy8gLS0tIERlZmluZSBCYXNlIExheWVycyAtLS1cbiAgICAgIGNvbnN0IG9zbUxheWVyID0gTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywge1xuICAgICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVzcmlTYXRlbGxpdGVMYXllciA9IEwudGlsZUxheWVyKCdodHRwczovL3NlcnZlci5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL1dvcmxkX0ltYWdlcnkvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLCB7XG4gICAgICAgIGF0dHJpYnV0aW9uOiAnVGlsZXMgJmNvcHk7IEVzcmkgJm1kYXNoOyBTb3VyY2U6IEVzcmksIGktY3ViZWQsIFVTREEsIFVTR1MsIEFFWCwgR2VvRXllLCBHZXRtYXBwaW5nLCBBZXJvZ3JpZCwgSUdOLCBJR1AsIFVQUi1FR1AsIGFuZCB0aGUgR0lTIFVzZXIgQ29tbXVuaXR5J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBkZWZhdWx0IGJhc2UgbGF5ZXIgKE9TTSlcbiAgICAgIG9zbUxheWVyLmFkZFRvKG1hcFJlZi5jdXJyZW50KTtcblxuICAgICAgLy8gLS0tIERlZmluZSBPdmVybGF5IExheWVycyAtLS1cbiAgICAgIGNvbnN0IG92ZXJsYXlNYXBzID0ge307IC8vIFdpbGwgYmUgcG9wdWxhdGVkIGxhdGVyXG5cbiAgICAgIC8vIC0tLSBBZGQgTGF5ZXJzIENvbnRyb2wgLS0tXG4gICAgICBjb25zdCBiYXNlTWFwcyA9IHtcbiAgICAgICAgXCJPcGVuU3RyZWV0TWFwXCI6IG9zbUxheWVyLFxuICAgICAgICBcIlNhdMOpbGl0ZSAoRVNSSSlcIjogZXNyaVNhdGVsbGl0ZUxheWVyXG4gICAgICB9O1xuICAgICAgbGF5ZXJzQ29udHJvbFJlZi5jdXJyZW50ID0gTC5jb250cm9sLmxheWVycyhiYXNlTWFwcywgb3ZlcmxheU1hcHMpLmFkZFRvKG1hcFJlZi5jdXJyZW50KTtcblxuICAgICAgLy8gRml4IGZvciBtYXJrZXIgaWNvbnNcbiAgICAgIGRlbGV0ZSAoTC5JY29uLkRlZmF1bHQucHJvdG90eXBlIGFzIGFueSkuX2dldEljb25Vcmw7XG4gICAgICBMLkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xuICAgICAgICBpY29uUmV0aW5hVXJsOiAnaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjkuNC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi0yeC5wbmcnLFxuICAgICAgICBpY29uVXJsOiAnaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjkuNC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmcnLFxuICAgICAgICBzaGFkb3dVcmw6ICdodHRwczovL3VucGtnLmNvbS9sZWFmbGV0QDEuOS40L2Rpc3QvaW1hZ2VzL21hcmtlci1zaGFkb3cucG5nJyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBMb2FkIEZhcm0gS01MIGRhdGFcbiAgICAgIGNvbnN0IGZhcm1LTUxzID0gW1xuICAgICAgICB7IHVybDogXG4gICAgICAgICAgJy9kb2Mua21sJywgbmFtZTogJ0ZhemVuZGEgQXRhbGFpYScgXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkaWNpb25lIG1haXMgS01McyBhcXVpLCBwb3IgZXhlbXBsbzpcbiAgICAgICAgLy8geyB1cmw6ICcvb3V0cmFfZmF6ZW5kYS5rbWwnLCBuYW1lOiAnT3V0cmEgRmF6ZW5kYScgfSxcbiAgICAgIF07XG5cbiAgICAgIGZhcm1LTUxzLmZvckVhY2goZmFybSA9PiB7XG4gICAgICAgIGxvYWRGYXJtS01MKGZhcm0udXJsLCBmYXJtLm5hbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluaXRpYWwgZmV0Y2ggb2YgSU5QRSBGaXJlIEtNTCBkYXRhXG4gICAgICB1cGRhdGVGaXJlRGF0YSgpOyAvLyBUaGlzIHdpbGwgbm93IGFsc28gYWRkIGZpcmUgbGF5ZXJzIHRvIHRoZSBjb250cm9sXG5cbiAgICAgIC8vIFNldCB1cCBpbnRlcnZhbCBmb3IgcGVyaW9kaWMgdXBkYXRlc1xuICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHVwZGF0ZUZpcmVEYXRhLCBSRUZSRVNIX0lOVEVSVkFMKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGludGVydmFsSWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgIH1cbiAgICAgIC8vIE9wdGlvbmFsOiBDbGVhbiB1cCBtYXAgaW5zdGFuY2UgaWYgY29tcG9uZW50IHVubW91bnRzXG4gICAgICAvLyBpZiAobWFwUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vICAgbWFwUmVmLmN1cnJlbnQucmVtb3ZlKCk7XG4gICAgICAvLyAgIG1hcFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIC8vIH1cbiAgICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtjZW50ZXIsIHpvb21dKTsgLy8gT25seSByZS1ydW4gaWYgY2VudGVyL3pvb20gcHJvcHMgY2hhbmdlXG5cblxuICByZXR1cm4gPGRpdiByZWY9e21hcENvbnRhaW5lclJlZn0gc3R5bGU9e3sgaGVpZ2h0OiAnMTAwdmgnLCB3aWR0aDogJzEwMCUnIH19IC8+O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ29tcG9uZW50O1xuXG5cblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJMIiwiRE9NUGFyc2VyIiwia21sIiwiaW5wZVVybHMiLCJmaXJlSWNvbiIsImljb24iLCJpY29uVXJsIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwicG9wdXBBbmNob3IiLCJSRUZSRVNIX0lOVEVSVkFMIiwiTWFwQ29tcG9uZW50IiwiY2VudGVyIiwiem9vbSIsIm1hcENvbnRhaW5lclJlZiIsIm1hcFJlZiIsImZpcmVEYXRhTGF5ZXJzIiwic2V0RmlyZURhdGFMYXllcnMiLCJmYXJtTGF5ZXJSZWYiLCJsYXllcnNDb250cm9sUmVmIiwiZmV0Y2hBbmRQcm9jZXNzRmlyZUtNTCIsImlucGVVcmwiLCJwcm94eUFwaVVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwia21sVGV4dCIsInRleHQiLCJwcm9jZXNzS01MVGV4dCIsImVycm9yIiwiY29uc29sZSIsInNvdXJjZVVybCIsInBhcnNlciIsImttbERvYyIsInBhcnNlRnJvbVN0cmluZyIsInBhcnNlcmVycm9yTlMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInRleHRDb250ZW50IiwiZ2VvanNvbiIsInBvaW50RmVhdHVyZXMiLCJmZWF0dXJlcyIsImZpbHRlciIsImZlYXR1cmUiLCJnZW9tZXRyeSIsInR5cGUiLCJwb2ludEZlYXR1cmVDb2xsZWN0aW9uIiwibG9nIiwiZ2VvSlNPTiIsImxheWVyIiwicG9pbnRUb0xheWVyIiwibGF0bG5nIiwibWFya2VyIiwib25FYWNoRmVhdHVyZSIsInByb3BlcnRpZXMiLCJwb3B1cENvbnRlbnQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJkZXNjIiwiZGF0ZVRpbWVNYXRjaCIsIm1hdGNoIiwic2F0ZWxsaXRlTWF0Y2giLCJtdW5pY2lwaW9NYXRjaCIsImVzdGFkb01hdGNoIiwiYmluZFBvcHVwIiwicGFyc2VFcnJvciIsInVwZGF0ZUZpcmVEYXRhIiwiY3VycmVudCIsIm5ld0xheWVycyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJ1cmwiLCJ2YWxpZE5ld0xheWVycyIsImZvckVhY2giLCJyZW1vdmVMYXllciIsImZpcmVMYXllckdyb3VwIiwibGF5ZXJHcm91cCIsImFkZExheWVyIiwiYWRkT3ZlcmxheSIsInJlZHVjZSIsImFjYyIsImdldExheWVycyIsImxvYWRGYXJtS01MIiwia21sVXJsIiwibGF5ZXJOYW1lIiwid2FybiIsIm5ld0Zhcm1MYXllciIsInN0eWxlIiwiY29sb3IiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwiZmlsbE9wYWNpdHkiLCJmaWxsQ29sb3IiLCJzdHlsZVVybCIsImluY2x1ZGVzIiwiYWRkVG8iLCJib3VuZHMiLCJnZXRCb3VuZHMiLCJpc1ZhbGlkIiwiZml0Qm91bmRzIiwicGFkZGluZyIsImlzTW91bnRlZCIsImludGVydmFsSWQiLCJvc21MYXllciIsInRpbGVMYXllciIsImF0dHJpYnV0aW9uIiwiZXNyaVNhdGVsbGl0ZUxheWVyIiwib3ZlcmxheU1hcHMiLCJiYXNlTWFwcyIsImNvbnRyb2wiLCJsYXllcnMiLCJJY29uIiwiRGVmYXVsdCIsInByb3RvdHlwZSIsIl9nZXRJY29uVXJsIiwibWVyZ2VPcHRpb25zIiwiaWNvblJldGluYVVybCIsInNoYWRvd1VybCIsImZhcm1LTUxzIiwiZmFybSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRpdiIsInJlZiIsImhlaWdodCIsIndpZHRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/MapComponent.tsx\n"));

/***/ })

});